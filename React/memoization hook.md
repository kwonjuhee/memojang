## 리렌더링 조건

- props, state, 구독하고 있는 context가 변경되었을 때 (얕은 비교)
- 부모 컴포넌트가 리렌더링되었을 때

## 렌더링 최적화

> **메모이제이션(memoization)** 은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

### React.memo

- 컴포넌트를 메모이제이션한다.
- 해당 컴포넌트가 받는 props 값이 변경되지 않는 이상 리렌더링을 방지한다.
  - 참조 값을 prop으로 받을 경우 (함수나 객체) 메모이제이션 해야함 (useCallback / useMemo)
- 고차 컴포넌트

### useCallback

- 함수를 메모이제이션한다.
- 컴포넌트의 실행 사이클마다 함수가 재생성되어 참조 값이 변경되는 것을 방지한다. (deps가 변경되면 재생성)
- 메모이제이션된 컴포넌트의 prop으로 함수를 넘겨주는 경우 참조 값을 유지하기 위해 사용
- ⚠️ closure trap 주의
  - 함수 내에서 외부 변수 사용시 함수가 생성될 당시의 변수 값을 기억하고 사용한다.
  - 사용하는 변수를 deps에 추가하도록 하자
- ⚠️ useCallback으로 props의 참조 동일성을 유지하더라도 리렌더링이 발생하는 이유
  - 부모 컴포넌트의 리렌더링은 자식 컴포넌트의 리렌더링을 일으킨다.
  - 때문에 자식 컴포넌트에 memo를 적용해야 한다.

### useMemo

- 값을 메모이제이션한다. 리렌더링시 캐싱된 값 반환
- 컴포넌트가 리렌더링될 때 무거운 작업이 다시 수행되는 것을 방지한다. (ex. 정렬)
- 어떤 종류의 데이터든지 저장 가능

## 메모이제이션 적용시 주의할 점

💡 최적화도 비용을 수반하므로 잘못 적용시 성능이 오히려 악화될 수 있다.

- 이전 값을 저장해야 하므로 메모리 사용이 증가
  - 컴포넌트는 기본적으로 이전 렌더링 결과가 저장되므로 memo는 해당되지 않음
- 비교 연산이 오히려 오버헤드로 작용할 수 있다.
  - props나 deps가 자주 변경되는 경우 비교 연산 + 리렌더링/재실행
  - 어짜피 메모이제이션된 값 사용못하는데 불필요한 비교 연산이 추가로 드는 것

💡 코드를 복잡하게 만들고 deps 실수로 인해 디버깅 시간이 더 소모될 수 있다.

=> 성능 개선의 필요성이 느껴질때 프로파일링해서 필요한 곳에만 적용하자

https://kentcdodds.com/blog/usememo-and-usecallback

### 고려해볼만한 상황

- 같은 props로 리렌더링이 자주 일어나는 경우
- 컴포넌트에 무겁고 비용이 큰 연산이 있는 경우
- 거대한 컴포넌트 트리에서 렌더링 전파를 막고자 가지치기가 필요한 경우
- 상단 컴포넌트 (ex. context provider)
