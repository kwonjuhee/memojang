## 자바스크립트 엔진 구조

<img src="https://user-images.githubusercontent.com/62097867/215311653-0f51b6f3-9b5b-4438-9888-e8b2dbcd2e6e.png" width="500px" />

- Memory Heap : 메모리 할당이 일어나는 곳
- Call Stack : 코드가 실행될 때 스택이 쌓이는 곳

## 자바스크립트 엔진 동작 과정 (V8 기준)

> V8은 구글이 개발한 C++로 작성된 고성능의 자바스크립트 & 웹 어셈블리 엔진으로 현재 크롬과 Node.js에서 사용되고 있다.

<img src="https://user-images.githubusercontent.com/62097867/210177294-5ede3515-022a-4022-9e76-74060c856bd8.png" width="600px" />

1. 먼저 자바스크립트 소스코드를 파서에게 넘긴다.

2. 파서는 소스코드를 파싱하여 AST로 변환한다.

3. AST를 인터프리터에게 넘긴다. (Ignition)

4. 인터프리터는 AST를 바이트코드로 변환한다.

5. 이후 바이트코드를 실행함으로써 소스코드가 작동하게 된다.

6. 그 중 자주 사용되는 코드는 TurboFan으로 보내져서 최적화된 코드로 컴파일된다. 사용이 덜 된다 싶으면 deoptimizing 하기도 한다. (in 백그라운드 스레드)

> 🔎 최적화 기준
>
> - 함수가 호출된 수가 임계점을 넘는 경우
> - 함수가 인라인 캐싱되지 않았고 바이트코드의 길이가 작은 경우

5~6번처럼 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일하는 방법을 JIT(Just-In-Time) Compilation라 한다.

https://evan-moon.github.io/2019/06/28/v8-analysis/

## JIT Compiler

중간 언어(IR)인 바이트코드를 기계어로 변환(컴파일)하여 수행하는 방법

![image](https://user-images.githubusercontent.com/62097867/215258319-7bbc60ef-4cae-4703-b987-f049ea8663af.png)

- 많은 최적화 알고리즘을 적용할 수 있는 static compiler와 달리 JITC는 런타임에 컴파일되기 때문에 최소한의 최적화만 적용이 가능하다.
- 하지만 이런 컴파일 오버헤드에도 불구하고 인터프리터보다 native code의 수행 성능이 월등히 좋기 때문에 사용한다.

### 자바스크립트에서의 문제점

💡자바스크립트는 동적인 언어이기 때문

예를 들어, 모든 타입 케이스를 고려하여 컴파일을 진행한다면 엄청나게 많은 native code가 생성될 것이다.
따라서 예외적인 케이스일 경우 native code로 변환하는 대신 엔진 내부에 C로 구현된 helper function을 호출하게 된다.

하지만 helper function은 인터프리터 모드로 수행할 때와 똑같은 코드를 사용하게 되는 것이므로 성능상 인터프리터와 별반 차이가 없게 된다.
게다가 컴파일 오버헤드가 더해지므로 더 비효율적일 수 있다.

### 개선된 JIT Compiler (+adaptive compilation)

자바스크립트 엔진에 profiler를 추가하여 함수의 호출빈도와 변수의 타입과 값을 기록한다.

모든 코드는 기본적으로 interpreter로 수행되며 그러다가 자주 반복되는 부분(hotspot)이 발견되면 그 부분만 컴파일하여 수행한다.

또한 반복 정도에 따라 다른 최적화 수준을 적용한다.

https://meetup.nhncloud.com/posts/77

## 비고

<img src="https://user-images.githubusercontent.com/62097867/215258219-8c71ead0-0f8c-464f-bfc7-5ba812bbb92c.png" width="600px" />

| Compiler                                                  | Interpreter                                                            |
| --------------------------------------------------------- | ---------------------------------------------------------------------- |
| 런타임전에 전체 소스코드를 기계어로 변환한다.             | 런타임에 한 줄씩 읽어가며 해당 기능에 대응하는 기계어 코드를 실행한다. |
| 미리 기계어로 변환해두기 때문에 실행 속도가 빠르다.       | 실행 속도가 느리다.                                                    |
| 최적화에 용이하다.                                        | 최적화가 어렵다.                                                       |
| 컴파일 과정에서 에러를 미리 발견할 수 있다.               | 프로그램 실행 중에 에러를 만나면 중지된다.                             |
| 중간 object code를 생성하여 더 많은 메모리를 필요로 한다. | 중간 object code를 생성하지 않아 메모리 효율이 높다.                   |
