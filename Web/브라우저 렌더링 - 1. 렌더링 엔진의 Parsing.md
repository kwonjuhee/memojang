## 🔎 렌더링 엔진

렌더링 엔진은 네트워크 레이어에서 문서의 내용을 가져오면 이를 파싱해서 브라우저 화면에 표시하는 역할을 한다.

렌더링 엔진은 크게 WebKit과 모질라에서 만든 Gecko 엔진이 있다.

- 크롬, 오페라 - WebKit을 기반으로 한 Blink
- 크롬(iOS), 사파리 - WebKit
- Firefox - Gecko

렌더링 엔진의 기본 흐름은 다음과 같다.

![image](https://user-images.githubusercontent.com/62097867/210098555-15c5fb5e-cd2f-4e05-9d2e-295ee4363328.png)

1. HTML을 파싱해서 DOM 트리를 구성한다.
2. CSS를 파싱하고 스타일 정보와 함께 렌더 트리를 구성한다.
3. layout - 렌더 트리의 각 노드가 표시되어야 하는 정확한 좌표를 계산하여
4. painting - 렌더 트리를 순회하며 UI 백엔드 레이어를 사용하여 각 노드를 그린다.

### main flow examples

![image](https://user-images.githubusercontent.com/62097867/210085609-f7787df5-96f2-455b-b0ca-4d7f0210c4e0.png)

WebKit과 Gecko는 약간 다른 용어를 사용하지만 기본적인 플로우는 같다.

## 🔎 일반적인 Parsing

Parsing이란 어휘 분석과 구문 분석을 통해 parse tree를 만들어 나가는 과정을 말한다.

> - 어휘 분석(lexical analysis) : 문자열을 유효한 토큰으로 분해
> - 구문 분석(syntax analysis) : 토큰에 문법적 의미와 구조 반영

![image](https://user-images.githubusercontent.com/62097867/210165510-c19ecd37-054e-4f18-b16b-dd162fa5430d.png)

parser는 lexer에게 새로운 토큰을 요청하여 토큰을 받아온 뒤 토큰이 문법 규칙에 맞는지 확인한다.

- 규칙에 맞으면 parse tree에 추가하고 다른 토큰을 요청한다.
- 규칙에 맞지 않으면 parser는 내부에 토큰을 저장하고 내부에 저장된 모든 토큰과 일치하는 규칙을 찾을 때까지
  토큰을 계속해서 요청한다.
- 해당하는 규칙이 없으면 syntax error를 발생시킨다.

### 파서 생성기

언어의 문법(어휘와 구문 규칙)을 제공하면 자동으로 파서를 생성할 수 있는 도구가 있다.

많은 프로그래밍 언어 문법은 문맥 자유 문법을 따르기 때문에 _(어휘를 정규 표현식으로 표현하여 정의하고, 구문을 BNF 형식에 따라 정의하는 식으로)_ 파서 생성기를 이용하여 파서를 만들 수 있다.

직접 파서를 만들려면 파싱에 대한 깊은 이해를 필요로 할뿐더러 최적화된 파서를 만드는 것이 쉬운 일이 아니기에 파서 생성기는 매우 유용하다.

### HTML 파서

관습적인 파서는 HTML에 적용할 수 없다. HTML은 너그러운 문법을 제공하기 때문에 파서가 필요로 하는 문맥 자유 문법에 의해 쉽게 정의할 수 없기 때문.
(시작이나 종료 태그를 생략해도 문법 오류가 발생하지 않는다던지)

따라서 브라우저는 별도의 HTML 파서를 만들어 사용한다.
파싱 알고리즘은 토큰화, 트리 구축 두 단계로 이루어져 있다.

### CSS 파서

CSS는 HTML과 달리 문맥 자유 문법을 따른다.
CSS 어휘는 토큰화를 위해 정규표현식으로 정의되어 있고, 구문 문법은 BNF로 구성되어 있다.
따라서 파서 생성기를 통해 파서를 생성할 수 있다.

WebKit은 Lexer를 생성하는 Flex와 Parser를 생성하는 Bison을 사용하여 파서를 자동생성한다.

## 🤖 HTML Parsing 과정

<img src="https://user-images.githubusercontent.com/62097867/210168230-0351f589-3190-411e-b4ab-426a8da2988d.png" width="300px" />

**1. 바이트 -> 문자열**

바이트 형태로 응답받은 HTML 문서를 응답 헤더에 명시된 인코딩 방식을 확인하여 문자열로 변환한다.

응답 헤더 예시 `content-type: text/html; charset=utf-8`

**2. 토큰화**

문자열로 변환된 HTML 문서를 토큰으로 파싱한다. 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값

문자를 계속 읽어 나가면서 토큰을 인식하면 tree constrcutor에게 넘긴다.

**3. 트리 구축**

tokenizer가 전달한 토큰에 맞는 DOM 요소를 생성한다.

열린 태그를 만나면 open element stack에 push하고 종료 태그를 만나면 해당 태그를 pop하는 과정을 반복한다.
이때 잘못된 중첩 관계나 닫지 않은 태그는 교정된다.

**4. DOM 트리 완성**

## 🤖 CSS Parsing

<link\> 태그를 만나 CSS 파일이 로드되면 CSS 파일은 CSSOM으로 파싱된다.
각 object는 CSS rule을 포함하며 CSS rule은 selector와 declaration object, css 문법과 일치하는 다른 object로 구성된다.

<img src="https://user-images.githubusercontent.com/62097867/210166950-7d23fb4f-ee49-415b-b411-fdc22934ff99.png" width="500px" />

## 파싱 진행 순서

### scripts

파서가 <scripts\> 태그를 만나면 스크립트가 실행될 때까지 파싱을 중단한다.

스크립트가 외부에 있는 경우 네트워크를 통해 리소스를 가져오는 동안에도 파싱이 중단된다.

script 태그에 `defer` 속성을 추가하면 문서 파싱을 중단하지 않고 문서가 파싱된 이후에 실행하도록 할 수 있다.
HTML5에서는 `async` 속성도 추가되었다.

### 예측 파싱 (Speculative Parsing)

WebKit과 Firefox는 예측 파싱과 같은 최적화를 지원한다.

예측 파싱이란 스크립트를 실행하는 동안 다른 스레드가 나머지 문서를 파싱하여 네트워크를 통해 로드해야할 외부 리소스(외부 스크립트, style sheets, images)를 찾고 로드하는 것을 말한다.
예측 파서는 오직 외부 리소스에 대한 참조만 파싱하며 DOM 트리를 수정하지 않고 메인 파서의 일로 넘긴다.

WebKit과 Firefox는 모두 예측 파싱을 지원하며 이 방식은 리소스를 병렬로 로드할 수 있어 속도를 개선한다.
이 방식은 리소스를 병렬로 로드할 수 있도록하여 속도를 개선한다.

### style sheet

스타일시트는 DOM 트리를 변경하지 않아 문서 파싱을 중단할 필요가 없지만

스크립트가 로드되지 않았거나 파싱되지 않은 스타일 정보를 요청하는 경우 잘못된 결과를 반환하여 문제가 발생할 수 있다.

따라서 파이어폭스에서는 로드 중이거나 파싱중인 스타일 시트가 있으면 스크립트 실행을 중단시키고,
WebKit에서는 로드되지 않은 스타일 시트의 스타일 속성에 접근하려고 할 때만 중단시킨다.
