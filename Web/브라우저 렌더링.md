## 브라우저 기본 구조

<p>
  <img src="https://user-images.githubusercontent.com/62097867/210097568-57e45c21-ca3e-437b-b492-caab9f43da73.png" width="500px" />
  <img src="https://user-images.githubusercontent.com/62097867/210097875-eea9bf11-00b3-4716-8c66-652f1a74c0b2.png" width="500px" />
</p>

**1. 사용자 인터페이스** : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.

**2. 브라우저 엔진** : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다. 주소 표시줄, 이전/다음 버튼 등 브라우저의 동작 부분을 제어한다. 파일 접근에 필요한 권한 처리도 이루어진다.

**3. 렌더링 엔진** : 웹 사이트가 표시되는 영역을 모두 제어한다. 요청한 콘텐츠를 파싱하고 화면에 표시한다.

**4. 통신** : HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼에 독립적인 인터페이스

**5. UI 백엔드** : 기본 위젯을 그릴 때 사용된다. 특정 플랫폼이 아닌 OS 사용자 인터페이스 체계를 사용한다.

**6. 자바스크립트 인터프리터** : 자바스크립트 코드를 파싱하고 실행할 때 사용된다.

**7. 데이터 저장소** : 쿠키나 로컬 스토리지, IndexedDB 등 데이터를 브라우저 내에서 로컬로 저장할 수 있도록 스토리지 메커니즘 지원

### 🔎 렌더링 엔진

렌더링 엔진은 네트워크 레이어에서 문서의 내용을 가져오면 이를 파싱해서 브라우저 화면에 표시하는 역할을 한다.

렌더링 엔진은 크게 WebKit과 모질라에서 만든 Gecko 엔진이 있다.

- 크롬, 오페라 - WebKit을 기반으로 한 Blink
- 크롬(iOS), 사파리 - WebKit
- Firefox - Gecko

### 🔎 자바스크립트 엔진

자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다.

자바스크립트 엔진에는 구글 크롬과 Node.js의 V8, 파이어폭스의 SpiderMonkey, 사파리의 JavaScriptCore 등 다양한 종류가 있으며, 모든 자바스크립트 엔진은 ECMAScript 사양을 준수한다.

## Critical Rendering Path

웹 사이트에 접속하면 브라우저가 서버에 요청을 보내 HTML 문서를 응답으로 받는다.

<p align="center">
  <img src="https://user-images.githubusercontent.com/62097867/215315379-d5f3988f-168d-4bc9-9027-f36866d40e1e.png" width="700px" />
</p>
  
### 1-1. HTML 파싱

<img src="https://user-images.githubusercontent.com/62097867/210168230-0351f589-3190-411e-b4ab-426a8da2988d.png" width="300px" />

**1. 바이트 -> 문자열**

- 바이트 형태로 응답받은 HTML 문서를 응답 헤더에 명시된 인코딩 방식을 확인하여 문자열로 변환한다.
- 응답 헤더 예시 `content-type: text/html; charset=utf-8`

**2. 토큰화**

- 문자열로 변환된 HTML 문서를 토큰으로 파싱한다. 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값
- 문자를 계속 읽어 나가면서 토큰을 인식하면 tree constrcutor에게 넘긴다.

**3. 트리 구축**

- tokenizer가 전달한 토큰에 맞는 DOM 요소를 생성한다.
- 열린 태그를 만나면 open element stack에 push하고 종료 태그를 만나면 해당 열린 태그까지의 노드들을 pop하여 자식 노드로 넣는 과정을 반복한다.
  - 이때 잘못된 중첩 관계나 닫지 않은 태그는 교정된다.

**4. DOM 트리 완성**

### 1-2. CSS 파싱

<img src="https://user-images.githubusercontent.com/62097867/210166950-7d23fb4f-ee49-415b-b411-fdc22934ff99.png" width="400px" />

1. CSS 파일을 요청하는 `<link>` 태그를 만나면 CSS 파일을 요청해서 받아온다.
2. CSS 파일은 HTML 파싱 과정과 동일하게 CSSOM으로 파싱된다.

각 object는 CSS rule을 포함하며 CSS rule은 selector와 declaration object, css 문법과 일치하는 다른 object로 구성된다.

### 1-3. 자바스크립트 파싱

<p align="center">
  <img src="https://user-images.githubusercontent.com/62097867/210181273-1e8d4388-d351-4980-941e-fdf18e2fb77f.png" />
</p>

1. <script\> 태그를 만나면 DOM 생성을 일시 중단한다.

2. 자바스크립트 엔진에게 제어권이 넘어간다.

3. 토크나이징(Tokenizing) : 자바스크립트 소스코드를 어휘 분석하여 문법적 의미를 갖는 최소 단위인 토큰들로 분해한다.

4. 파싱(Parsing) : 토큰들의 집합을 구문 분석하여 **AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성**한다.

5. 인터프리터가 AST를 기반으로 실행할 수 있는 중간 코드인 **바이트코드를 생성**한다.

6. 바이트코드를 실행하면서 자주 사용되는 코드는 최적화된 코드로 다시 컴파일된다. 이 코드가 자주 사용되지 않으면 다시 deoptimizing 되기도 한다.

7. 자바스크립트 파싱과 실행이 종료되면 다시 렌더링 엔진으로 제어권이 넘어가고 HTML 파싱이 중단된 지점부터 다시 파싱을 재개한다.

<details>
  <summary>🔎Parsing</summary>
  
### 일반적인 Parsing

Parsing이란 어휘 분석과 구문 분석을 통해 parse tree를 만들어 나가는 과정을 말한다.

> - 어휘 분석(lexical analysis) : 문자열을 유효한 토큰으로 분해
> - 구문 분석(syntax analysis) : 토큰에 문법적 의미와 구조 반영

![image](https://user-images.githubusercontent.com/62097867/210165510-c19ecd37-054e-4f18-b16b-dd162fa5430d.png)

parser는 lexer에게 새로운 토큰을 요청하여 토큰을 받아온 뒤 토큰이 문법 규칙에 맞는지 확인한다.

- 규칙에 맞으면 parse tree에 추가하고 다른 토큰을 요청한다.
- 규칙에 맞지 않으면 parser는 내부에 토큰을 저장하고 내부에 저장된 모든 토큰과 일치하는 규칙을 찾을 때까지
  토큰을 계속해서 요청한다.
- 해당하는 규칙이 없으면 syntax error를 발생시킨다.

### 파서 생성기

언어의 문법(어휘와 구문 규칙)을 제공하면 자동으로 파서를 생성할 수 있는 도구가 있다.

많은 프로그래밍 언어 문법은 문맥 자유 문법을 따르기 때문에 _(어휘를 정규 표현식으로 표현하여 정의하고, 구문을 BNF 형식에 따라 정의하는 식으로)_ 파서 생성기를 이용하여 파서를 만들 수 있다.

직접 파서를 만들려면 파싱에 대한 깊은 이해를 필요로 할뿐더러 최적화된 파서를 만드는 것이 쉬운 일이 아니기에 파서 생성기는 매우 유용하다.

**HTML 파서**

관습적인 파서는 HTML에 적용할 수 없다. HTML은 너그러운 문법을 제공하기 때문에 파서가 필요로 하는 문맥 자유 문법에 의해 쉽게 정의할 수 없기 때문.
(시작이나 종료 태그를 생략해도 문법 오류가 발생하지 않는다던지)

따라서 브라우저는 별도의 HTML 파서를 만들어 사용한다.
파싱 알고리즘은 토큰화, 트리 구축 두 단계로 이루어져 있다.

**CSS 파서**

CSS는 HTML과 달리 문맥 자유 문법을 따른다.
CSS 어휘는 토큰화를 위해 정규표현식으로 정의되어 있고, 구문 문법은 BNF로 구성되어 있다.
따라서 파서 생성기를 통해 파서를 생성할 수 있다.

WebKit은 Lexer를 생성하는 Flex와 Parser를 생성하는 Bison을 사용하여 파서를 자동생성한다.

</details>

### 2. 렌더 트리 생성

DOM 트리와 CSSOM 트리를 결합하여 **화면에 실제로 보이는 요소만**으로 렌더 트리를 생성하는 과정

- 렌더 트리는 layout과 paint 과정에 사용된다.

- WebKit에서 attachment라 한다.

> 1. DOM 트리의 root에서 시작하여 visible 노드를 탐색한다.
> 2. 각 노드에 맞는 CSSOM 규칙을 찾아 적용한다.
> 3. 노드의 콘텐츠와 계산된 스타일과 함께 렌더 트리 구성 요소를 생성한다. 렌더 트리의 구성 요소를 WebKit에서는 renderer(render object), Gecko에서는 frame이라 한다.
> 4. render object의 속성에 따라 필요한 경우 render layer를 생성한다.

```
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
```

**💡 DOM 트리와 렌더 트리의 관계**

- 렌더러는 DOM요소에 일치하지만 1:1 대응 관계는 아니다. 화면에 표시되지 않는 노드들은 렌더 트리에 반영되지 않기 때문.

  - <head\> <srcipt\> <meta\> display: none 등등
  - ⚠️ `visibility: hidden`은 화면에 공간을 차지하기 때문에 렌더 트리에 포함된다.

- float, absolute, fixed positioned 요소는 DOM 트리와는 다른 부분에 배치되고 placeholder frame이 원래 있어야할 곳에 배치된다.

### 3. Layout (Reflow)

렌더 트리가 생성되고 뷰포트내에서 **렌더러의 정확한 크기와 위치를 계산**하는 과정

- 모든 요소는 박스 형태로 되어있는데 박스의 크기, 위치, 높이를 계산한다.

- 모든 상대적인 측정값은 절대적인 픽셀로 변환된다. (좌표계는 left -> X축, top -> Y축을 사용)

- 상위 렌더러에서 하위로 내려가면서 재귀적으로 계산한다. (레이아웃이 필요한 자식 요소들의 layout 메서드를 호출)

> 1. 부모 렌더러가 자신의 너비를 계산
> 2. 부모가 자식 렌더러의 x, y 좌표를 배치한다.
> 3. 필요하다면(dirty이거나 global layout) 자식의 layout 메서드를 호출하여 자식의 높이를 계산한다.
> 4. 부모는 자식의 누적된 높이와 margin, padding을 사용하여 자신의 높이를 설정한다. 이 값은 부모의 부모가 사용하게 된다.
> 5. dirty bit flag를 제거한다.

> 🔎 Dirty bit system
>
> 작은 변경 사항으로 전체 레이아웃을 재배치하지 않기 위해 배치가 필요한 렌더러만 dirty bit flag를 표시하는 것을 말한다.
> 변경되었거나 추가된 렌더러와 그 자식을들 dirty로 지정한다.
>
> 두 가지 flag가 있다. => dirty, children are dirty

### 4. Paint

렌더 트리의 각 노드를 브라우저 화면에 픽셀로 나타내는 과정이다.
렌더 트리가 탐색되고 렌더러의 paint 메서드가 호출된다.

## 리렌더링

### 1. Reflow

![image](https://user-images.githubusercontent.com/62097867/215346097-4e665814-7dd7-4ee4-ab3b-b74eff5886c5.png)

- global layout : 페이지 전체에 관련된 레이아웃 변경

  - 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
  - 폰트 변경

- incremental layout (by dirty bit system): 크기나 위치같은 한정적인 레이아웃 변경
  - 자바스크립트에 의한 노드 추가 또는 삭제
  - HTML 요소의 레이아웃(위치, 크기)에 영향을 미치는 스타일 변경 (width/height, margin, padding, border, display, position, top/right/bottom/left 등)

### 2. Repaint

![image](https://user-images.githubusercontent.com/62097867/215346099-84d3a91f-c8c0-4aec-8c41-8f1ada0a9718.png)

- 레이아웃 수치에 영향을 미치지 않는 스타일 변경 (background-color, color, visibility, text-decoration 등)

### 3. Composite

![image](https://user-images.githubusercontent.com/62097867/215346163-b16e4fb5-0abd-4a78-9cca-07cc24ffe5b6.png)

- Layout과 Paint를 수행하지 않고 레이어의 합성만 발생하기 때문에 성능상 가장 큰 이점을 가진다.

렌더링 엔진마다 차이가 있다. (여기서 확인 https://csstriggers.com/)

https://web.dev/howbrowserswork/

https://web.dev/critical-rendering-path-render-tree-construction/

https://post.naver.com/viewer/postView.nhn?volumeNo=8431285&memberNo=34176766
